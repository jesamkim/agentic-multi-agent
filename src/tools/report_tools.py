"""
Report Generation Tools

Creates detailed HTML and PDF reports for ESG analyses.
"""

import subprocess
import json
import re
from pathlib import Path
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any
from strands import tool
import logging

logger = logging.getLogger(__name__)

# KST timezone (UTC+9)
KST = timezone(timedelta(hours=9))

try:
    import markdown
    MARKDOWN_AVAILABLE = True
except ImportError:
    MARKDOWN_AVAILABLE = False
    logger.warning("markdown library not available - markdown conversion disabled")


def _is_markdown(content: str) -> bool:
    """
    Detect if content is Markdown (not HTML).

    Returns True if content contains Markdown syntax.
    """
    markdown_patterns = [
        r'^##\s+',  # Markdown headers
        r'\*\*.*\*\*',  # Bold (anywhere in text)
        r'^\*\s+',  # Bullet lists
        r'^\d+\.\s+',  # Numbered lists
        r'\[.*\]\(.*\)',  # Links
    ]

    for pattern in markdown_patterns:
        if re.search(pattern, content, re.MULTILINE):
            return True
    return False


def create_html_report(
    title: str,
    content: str,
    metadata: Optional[Dict[str, Any]] = None
) -> str:
    """
    Create HTML report with professional styling.

    Args:
        title: Report title
        content: Main content (Markdown or HTML)
        metadata: Optional metadata (author, date, etc)

    Returns:
        HTML string
    """
    timestamp = datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S KST")

    # Auto-detect and convert Markdown to HTML if needed
    if _is_markdown(content):
        logger.warning("Content appears to be Markdown - converting to HTML")
        if MARKDOWN_AVAILABLE:
            html_content = markdown.markdown(
                content,
                extensions=['tables', 'fenced_code', 'nl2br']
            )
            logger.info("Successfully converted Markdown to HTML")
        else:
            logger.error("Markdown library not available - cannot convert")
            html_content = f"<pre>{content}</pre>"  # Fallback: display as-is
    else:
        # Content is already HTML (generated by Report Agent)
        html_content = content

    html_template = f"""
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px;
            background: #f5f5f5;
        }}
        .container {{
            background: white;
            padding: 60px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }}
        h1 {{
            color: #1a73e8;
            border-bottom: 3px solid #1a73e8;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }}
        h2 {{
            color: #34a853;
            margin-top: 40px;
            margin-bottom: 20px;
        }}
        h3 {{
            color: #ea4335;
            margin-top: 30px;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }}
        th {{
            background-color: #1a73e8;
            color: white;
            font-weight: bold;
        }}
        tr:nth-child(even) {{
            background-color: #f9f9f9;
        }}
        .metadata {{
            color: #666;
            font-size: 0.9em;
            margin-bottom: 30px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
        }}
        .highlight {{
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }}
        ul, ol {{
            margin: 15px 0;
            padding-left: 30px;
        }}
        li {{
            margin: 8px 0;
        }}
        code {{
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }}
        .footer {{
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 0.85em;
            text-align: center;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>{title}</h1>
        <div class="metadata">
            <strong>Generated:</strong> {timestamp}<br>
            <strong>Source:</strong> Samsung C&T ESG Chatbot - Multi-Agent System
        </div>

        <div class="content">
            {html_content}
        </div>
        
        <div class="footer">
            <p>Samsung C&T ESG Analysis Report</p>
            <p>Generated by Strands Agents Multi-Agent System</p>
        </div>
    </div>
</body>
</html>
"""
    return html_template


def generate_report_stepwise_append(
    topic: str,
    data: str,
    output_path: Path
) -> str:
    """
    Generate HTML report step-by-step with file append (streaming style).

    Each step generates a section and immediately appends to file.
    Prevents timeout by keeping each API call short.
    Similar to pdf_to_markdown.py streaming approach.

    Args:
        topic: Report title
        data: Source data for report
        output_path: HTML file path

    Returns:
        Final HTML file path
    """
    from src.agents.report_agent import report_agent

    logger.info("Generating report step-by-step with HTML append...")

    # Truncate data if too long
    data_summary = data[:2000] if len(data) > 2000 else data

    try:
        # Step 1: Create HTML file with header
        logger.info("Step 1/5: Creating HTML file header...")
        html_header = f"""<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{topic}</title>
    <style>
        body {{
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px;
            background: #f5f5f5;
        }}
        .container {{
            background: white;
            padding: 60px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }}
        h1 {{
            color: #1a73e8;
            border-bottom: 3px solid #1a73e8;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }}
        h2 {{
            color: #34a853;
            margin-top: 40px;
            margin-bottom: 20px;
        }}
        h3 {{
            color: #ea4335;
            margin-top: 30px;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }}
        th {{
            background-color: #1a73e8;
            color: white;
            font-weight: bold;
        }}
        tr:nth-child(even) {{
            background-color: #f9f9f9;
        }}
        .metadata {{
            color: #666;
            font-size: 0.9em;
            margin-bottom: 30px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
        }}
        ul, ol {{
            margin: 15px 0;
            padding-left: 30px;
        }}
        li {{
            margin: 8px 0;
        }}
        .footer {{
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 0.85em;
            text-align: center;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>{topic}</h1>
        <div class="metadata">
            <strong>Generated:</strong> {datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S KST")}<br>
            <strong>Source:</strong> Samsung C&T ESG Chatbot - Multi-Agent System
        </div>

        <div class="content">
"""

        # Write header
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_header)
        logger.info(f"HTML header written to {output_path}")

        # Step 2: Generate & append Executive Summary
        logger.info("Step 2/5: Generating Executive Summary...")
        prompt_1 = f"""Generate ONLY Executive Summary section in HTML for: {topic}

Data: {data_summary}

Output format:
<h2>Executive Summary</h2>
<p>2-3 paragraphs in KOREAN...</p>

IMPORTANT:
- Write in KOREAN (한글)
- NO code block markers (no ```html)
- Start directly with <h2> tag

Be comprehensive and professional."""

        section_1 = str(report_agent(prompt_1))

        # Remove code block markers if present
        section_1 = section_1.replace('```html', '').replace('```', '').strip()

        with open(output_path, 'a', encoding='utf-8') as f:
            f.write(f"\n{section_1}\n")
        logger.info("Executive Summary appended")

        # Step 3: Generate & append Detailed Analysis
        logger.info("Step 3/5: Generating Detailed Analysis...")
        prompt_2 = f"""Generate ONLY Detailed Analysis section in HTML for: {topic}

Data: {data}

Output format:
<h2>Detailed Analysis</h2>
<p>Main findings in KOREAN...</p>
<h3>Key Metrics</h3>
<table>...</table>

IMPORTANT:
- Write in KOREAN (한글)
- NO code block markers
- Start directly with <h2> tag

Use tables and subsections. Be thorough."""

        section_2 = str(report_agent(prompt_2))

        # Remove code block markers if present
        section_2 = section_2.replace('```html', '').replace('```', '').strip()

        with open(output_path, 'a', encoding='utf-8') as f:
            f.write(f"\n{section_2}\n")
        logger.info("Detailed Analysis appended")

        # Step 4: Generate & append Conclusions
        logger.info("Step 4/5: Generating Conclusions...")
        prompt_3 = f"""Generate ONLY Conclusions and Recommendations section in HTML for: {topic}

Data: {data_summary}

Output format:
<h2>Conclusions and Recommendations</h2>
<p>Summary in KOREAN...</p>
<ul><li>Recommendation 1</li></ul>

IMPORTANT:
- Write in KOREAN (한글)
- NO code block markers
- Start directly with <h2> tag

Be concise and actionable."""

        section_3 = str(report_agent(prompt_3))

        # Remove code block markers if present
        section_3 = section_3.replace('```html', '').replace('```', '').strip()

        with open(output_path, 'a', encoding='utf-8') as f:
            f.write(f"\n{section_3}\n")
        logger.info("Conclusions appended")

        # Step 5: Close HTML file
        logger.info("Step 5/5: Closing HTML file...")
        html_footer = """
        </div>

        <div class="footer">
            <p>Samsung C&T ESG Analysis Report</p>
            <p>Generated by Strands Agents Multi-Agent System</p>
        </div>
    </div>
</body>
</html>
"""
        with open(output_path, 'a', encoding='utf-8') as f:
            f.write(html_footer)
        logger.info(f"HTML report completed: {output_path}")

        return str(output_path)

    except Exception as e:
        logger.error(f"Stepwise generation failed: {str(e)}")
        raise


def convert_html_to_pdf_simple(
    html_path: str,
    output_path: str,
    scale: float = 0.8
) -> bool:
    """
    Convert HTML file to PDF using html2pdf MCP tool.

    This is a simple wrapper that uses Claude Code's built-in MCP tool.
    For Strands agents, we'll call this from Python.

    Args:
        html_path: Path to HTML file
        output_path: Output PDF file path
        scale: Page scale (default: 0.8 for 80%)

    Returns:
        True if successful, False otherwise
    """
    try:
        # Note: This function will be called by the report agent
        # which can use the mcp__html2pdf__convert_html_to_pdf tool directly

        # For now, return instructions to use MCP tool
        logger.info(f"Use mcp__html2pdf__convert_html_to_pdf for: {html_path} -> {output_path}")

        return True

    except Exception as e:
        logger.error(f"Error: {str(e)}")
        return False


def _generate_report_internal(
    topic: str,
    analysis_data: str,
    output_filename: Optional[str] = None
) -> str:
    """
    Generate detailed HTML and PDF report for ESG analysis.

    Automatically creates both HTML and PDF versions.

    Use this tool when user explicitly requests:
    - "보고서 만들어줘"
    - "상세 분석 문서 작성해줘"
    - "PDF로 저장해줘"
    - "자세한 리포트 필요해"

    Args:
        topic: Report topic/title
        analysis_data: Detailed analysis content to include in report
        output_filename: Optional custom filename (default: auto-generated)

    Returns:
        Message with both HTML and PDF file paths
    """
    try:
        logger.info(f"Generating detailed report: {topic}")

        # Create output filename with KST timestamp (timestamp first for sorting)
        if not output_filename:
            timestamp = datetime.now(KST).strftime("%Y%m%d_%H%M%S")
            safe_topic = "".join(c for c in topic if c.isalnum() or c in (' ', '_')).strip()
            safe_topic = safe_topic.replace(' ', '_')[:50]
            output_filename = f"{timestamp}_{safe_topic}"

        # Ensure reports directory exists
        reports_dir = Path("reports")
        reports_dir.mkdir(exist_ok=True)

        html_path = reports_dir / f"{output_filename}.html"
        pdf_path = reports_dir / f"{output_filename}.pdf"

        # Generate HTML step-by-step with append (timeout prevention)
        generate_report_stepwise_append(
            topic=topic,
            data=analysis_data,
            output_path=html_path
        )

        logger.info(f"HTML report completed: {html_path}")

        # Convert to PDF
        logger.info("Converting HTML to PDF...")

        mcp_dir = Path(__file__).parent.parent.parent / "mcp" / "html2pdf"
        abs_html_path = html_path.resolve()
        abs_pdf_path = pdf_path.resolve()

        # Create Node.js conversion script (ES modules)
        script = f"""
import {{ PdfConverter }} from './dist/pdf-converter.js';

async function convert() {{
    const converter = new PdfConverter();
    const result = await converter.convertToPdf({{
        htmlPath: '{abs_html_path}',
        outputPath: '{abs_pdf_path}',
        scale: 0.8,
        printBackground: true,
        format: 'A4',
        marginTop: '15mm',
        marginBottom: '15mm',
        marginLeft: '15mm',
        marginRight: '15mm'
    }});

    await converter.cleanup();

    if (result.success) {{
        console.log('SUCCESS');
    }} else {{
        console.error('FAILED:', result.error);
        process.exit(1);
    }}
}}

convert().catch(err => {{
    console.error('ERROR:', err.message);
    process.exit(1);
}});
"""

        script_path = mcp_dir / 'temp_report_convert.mjs'
        with open(script_path, 'w') as f:
            f.write(script)

        # Execute conversion
        result = subprocess.run(
            ['node', str(script_path)],
            cwd=str(mcp_dir.resolve()),
            capture_output=True,
            text=True,
            timeout=60
        )

        # Clean up
        script_path.unlink(missing_ok=True)

        # Return appropriate message
        if result.returncode == 0 and 'SUCCESS' in result.stdout:
            logger.info(f"PDF report saved: {pdf_path}")
            return f"""
보고서가 생성되었습니다:

- HTML: {html_path}
- PDF: {pdf_path} (scale 80%)

파일을 확인하시면 상세한 분석 내용을 보실 수 있습니다.
"""
        else:
            logger.warning(f"PDF conversion failed: {result.stderr}")
            return f"""
HTML 보고서가 생성되었습니다: {html_path}

(PDF 변환 실패 - HTML 파일을 사용해주세요)
"""

    except Exception as e:
        logger.error(f"Report generation failed: {str(e)}")
        return f"보고서 생성 중 오류 발생: {str(e)}"


@tool
def generate_detailed_report(
    topic: str,
    analysis_data: str,
    output_filename: Optional[str] = None
) -> str:
    """
    Generate detailed HTML and PDF report for ESG analysis.

    Automatically creates both HTML and PDF versions.

    Args:
        topic: Report topic/title
        analysis_data: Detailed analysis content
        output_filename: Optional custom filename

    Returns:
        Message with HTML and PDF file paths
    """
    return _generate_report_internal(topic, analysis_data, output_filename)


__all__ = [
    'create_html_report',
    'generate_detailed_report',
    'generate_report_stepwise_append',
    '_generate_report_internal'
]
